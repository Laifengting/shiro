# 一、Shiro 认证流程思路分析

## 第 1 步 获取当前的 Subject
```java
// 获取当前的 执行的用户 subject 主题，通过 SecurityUtils.getSubject();
Subject currentUser = SecurityUtils.getSubject();
```

## 第 2 步 校验当前 Subject 是否已经登录

```java
// 测试当前的用户是否已经被认证，是否已经登录。
// 调用 Subject$isAuthenticated() 方法
if (!currentUser.isAuthenticated()) {
	// 未认证处理
}
```

## 第 3 步 若没有被认证，则把用户名和密码封装为 UsernamePasswordToken 类型对象

```java
// let's login the current user so we can check against roles and permissions:
// 测试当前的用户是否已经被认证，是否已经登录。
// 调用 Subject$isAuthenticated() 方法
if (!currentUser.isAuthenticated()) {
    // 把用户名和密码封装成一个 token 对象（UsernamePasswordToken类型）
    UsernamePasswordToken token = new UsernamePasswordToken("lonestarr", "vespa");
    token.setRememberMe(true); // 设置是否记住我。也就是记住用户名和密码。
    try {
        currentUser.login(token); // 调用 Subject$login 方法执行登录
    } catch (UnknownAccountException uae) { // 未知账户异常
        log.error("There is no user with username of " + token.getPrincipal());
    } catch (IncorrectCredentialsException ice) { // 错误凭证异常
        log.error("Password for account " + token.getPrincipal() + " was incorrect!");
    } catch (LockedAccountException lae) { // 账户锁定异常
        log.error("The account for username " + token.getPrincipal() + " is locked.  " +
                          "Please contact your administrator to unlock it.");
    }
    // ... catch more exceptions here (maybe custom ones specific to your application?
    catch (AuthenticationException ae) { // 认证异常
        //unexpected condition?  error?
    }
}
```



### 3.1 在 SpringMVC 的 web.xml 文件中添加过滤器

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns = "http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation = "http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version = "4.0">

    <!-- 解决中文乱码的过滤器 注意这个过滤器要先加载。所以要放在前面 -->
    <filter>
        <filter-name>characterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>characterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- 配置 Shiro 的 ShiroFilter 过滤器 -->
    <!-- DelegatingFilterProxy 实际上是 Filter 的一个代理对象。默认情况下 Spring 会到 IOC 容器中查找和 <filter-name> 对应的 bean  -->
    <!-- 也可以 targetBeanName 的初始化参数来指定具体的 bean 名字（bean id） -->
    <filter>
        <filter-name>shiroFilter</filter-name>
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
        <init-param>
            <param-name>targetFilterLifecycle</param-name>
            <param-value>true</param-value>
        </init-param>
        <!--<init-param>-->
        <!--    <param-name>targetBeanName</param-name>-->
        <!--    <param-value>abc</param-value>-->
        <!--</init-param>-->
    </filter>
    <filter-mapping>
        <filter-name>shiroFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>

    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!--<listener>-->
    <!--    <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>-->
    <!--</listener>-->

    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
```



### 3.2 添加 SpringMVC 的配置文件 springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns = "http://www.springframework.org/schema/beans"
       xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context = "http://www.springframework.org/schema/context"
       xmlns:mvc = "http://www.springframework.org/schema/mvc"
       xsi:schemaLocation = "http://www.springframework.org/schema/beans
	   http://www.springframework.org/schema/beans/spring-beans.xsd
	   http://www.springframework.org/schema/context
	   http://www.springframework.org/schema/context/spring-context.xsd
	   http://www.springframework.org/schema/mvc
	   http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd">
    <!-- SpringMVC 只是控制网站跳转逻辑 -->
    <!--
	配置包扫描路径
		只扫描控制器
	-->
    <!-- 组件扫描 -->
    <context:component-scan base-package = "com.lft.shiro"/>

    <!-- 视图解析器 -->
    <bean class = "org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name = "prefix"
                  value = "/"/>
        <property name = "suffix"
                  value = ".jsp"/>
    </bean>

    <!-- 处理动态资源 -->
    <mvc:annotation-driven/>
    <!-- 正确处理静态资源 -->
    <mvc:default-servlet-handler/>
</beans>
```



### 3.3 添加 Spring 的配置文件 applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns = "http://www.springframework.org/schema/beans"
       xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation = "http://www.springframework.org/schema/beans
	   http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--========================== Shiro 配置 ==========================-->
    <!-- 1. 配置 SecurityManager -->
    <bean id = "securityManager"
          class = "org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <!-- 配置缓存管理器 -->
        <property name = "cacheManager"
                  ref = "cacheManager"/>

        <!-- 配置 Session 管理器 -->
        <!--<property name = "sessionManager"
                  ref = "sessionManager"/>-->

        <!-- 配置单个 Realm -->
        <!--<property name = "realm"
                  ref = "jdbcRealm"/>-->

        <!-- 配置多个 Realm -->
        <!--<property name = "realms">
            <list>
                <ref bean = "jdbcRealm"/>
                <ref bean = "secondRealm"/>
            </list>
        </property>-->

        <!-- 配置授权器 -->
        <property name = "authenticator"
                  ref = "authenticator"/>
    </bean>
    <!-- 2. 缓存管理器 -->
    <!-- 使用第三方缓存管理器，需要加入依赖和配置文件 -->
    <bean id = "cacheManager"
          class = "org.apache.shiro.cache.ehcache.EhCacheManager">
        <property name = "cacheManagerConfigFile"
                  value = "classpath:ehcache.xml"/>
    </bean>

    <!-- Session 管理器 -->
    <!--<bean id = "sessionManager"-->
    <!--      class = "org.apache.shiro.session.mgt.DefaultSessionManager">-->
    <!--</bean>-->

    <!-- 3. 配置 Realm -->
    <!-- 自定义一个类直接实现 Realm 接口 -->
    <bean id = "jdbcRealm"
          class = "com.lft.shiro.realms.MyFirstShiroAuthenticatingRealm">
        <!-- 指定凭证匹配器 -->
        <property name = "credentialsMatcher"
                  ref = "credentialsMatcher"/>
    </bean>
    <bean id = "secondRealm"
          class = "com.lft.shiro.realms.MySecondShiroAuthenticatingRealm">
        <!-- 指定凭证匹配器 -->
        <property name = "credentialsMatcher"
                  ref = "credentialsMatcher2"/>
    </bean>

    <!-- 授权管理器 -->
    <bean id = "authenticator"
          class = "org.apache.shiro.authc.pam.ModularRealmAuthenticator">
        <property name = "realms">
            <list>
                <ref bean = "jdbcRealm"/>
                <ref bean = "secondRealm"/>
            </list>
        </property>
    </bean>

    <!-- 凭证匹配器1 -->
    <bean id = "credentialsMatcher"
          class = "org.apache.shiro.authc.credential.HashedCredentialsMatcher">
        <!-- 算法名称 -->
        <property name = "hashAlgorithmName"
                  value = "MD5"/>
        <!-- 执行加密次数 -->
        <property name = "hashIterations"
                  value = "2"/>
    </bean>
    <!-- 凭证匹配器2 -->
    <bean id = "credentialsMatcher2"
          class = "org.apache.shiro.authc.credential.HashedCredentialsMatcher">
        <!-- 算法名称 -->
        <property name = "hashAlgorithmName"
                  value = "SHA1"/>
        <!-- 执行加密次数 -->
        <property name = "hashIterations"
                  value = "2"/>
    </bean>

    <!-- 4. 配置 LifecycleBeanPostProcessor 生命周期后置处理器 -->
    <!-- 可以自动管理配置在 Spring IOC 容器中 shiro Bean 的生命周期。 -->
    <bean id = "lifecycleBeanPostProcessor"
          class = "org.apache.shiro.spring.LifecycleBeanPostProcessor"/>

    <!-- 5. 在配置了 LifecycleBeanPostProcessor 之后，才能在 IOC 容器中使用 shiro 注解。 -->
    <bean class = "org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"
          depends-on = "lifecycleBeanPostProcessor"/>
    <bean class = "org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name = "securityManager"
                  ref = "securityManager"/>
    </bean>

    <!-- 6. 配置 ShiroFilter -->
    <!-- id名必须和 web.xml 中配置的过滤器名字 <filter-name> 一样。 -->
    <!-- 若不一致，则会抛出 NoSuchBeanDefinitionException 异常 因为，Shiro 会从 IOC 容器中查找 <filter-name> 名字对应的 filter -->
    <bean id = "shiroFilter"
          class = "org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name = "securityManager"
                  ref = "securityManager"/>
        <property name = "loginUrl"
                  value = "/login.jsp"/>
        <property name = "successUrl"
                  value = "/list.jsp"/>
        <property name = "unauthorizedUrl"
                  value = "/unauthorized.jsp"/>
        <!-- 配置哪些页面需要受保护 -->
        <!-- 1. anon 表示可以被匿名访问 2. authc 必须认证（登录）才能访问 -->
        <property name = "filterChainDefinitions">
            <value>
                <!--
                [urls] 格式为 url = 拦截器[参数],拦截器[参数]
                    anon (anonymous) 拦截器表示匿名访问
                    authc (authentication) 拦截器表示需要身份认证通过后才能访问
                    logout 退出拦截器

                支持 ant 风格模式：
                    ?：匹配一个字符，例如：/admin? 将匹配 /admin1，但不匹配 /admin 或 /admin/
                    *：匹配0个或多个字符，例如：/admin* 将匹配 /admin、/admin123 但不匹配 /admin/1
                    **：匹配路径中的0个或多个路径，例如：/admin/** 将匹配 /admin/、/admin/a、/admin/a/b

                匹配顺序：
                    URL 权限采取第一次匹配优先的方式。
                    从头开始使用第一个匹配的 url 模式对应的拦截器链。
                    例如：
                        /bb/** = filter1
                        /bb/aa = filter2
                        /**=filter3
                        如果请求的url 是 /bb/aa，因为按照声明顺序进行匹配，那么将使用 filter1 进行拦截
                -->
                /login.jsp = anon
                /shiro/login = anon
                /shiro/logout = logout
                /** = authc
            </value>
        </property>
    </bean>
</beans>
```



### 3.4 创建一个表单页面

 ```jsp
 <%--
   Created by IntelliJ IDEA.
   User: Laifengting
   Date: 2021-06-11
   Time: 8:53
   To change this template use File | Settings | File Templates.
 --%>
 <%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="UTF-8" %>
 <!DOCTYPE html>
 <html>
     <head>
         <meta charset="UTF-8">
         <title>Login Page</title>
     </head>
 
     <body>
         <h4>Login Page</h4> <br/>
 
         <form action="shiro/login" method="post">
             username: <input type="text" name="username">
             <br/>
             password: <input type="text" name="password">
             <input type="submit" value="提交">
         </form>
 
     </body>
 </html>
 ```



### 3.5 把前端的请求提交到 SpringMVC 的 Controller 上。

```java
package com.lft.shiro.controller;

import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.subject.Subject;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@RequestMapping ("shiro")
public class ShiroController {
    
    @PostMapping ("login")
    public String login(@RequestParam ("username") String username, @RequestParam ("password") String password) {
        Subject currentUser = SecurityUtils.getSubject();
        
        // 测试当前的用户是否已经被认证，是否已经登录。
        // 调用 Subject$isAuthenticated() 方法
        if (!currentUser.isAuthenticated()) {
            // 把用户名和密码封装成一个 token 对象（UsernamePasswordToken类型）
            UsernamePasswordToken token = new UsernamePasswordToken(username, password);
            // token.setRememberMe(true); // 设置是否记住我。也就是记住用户名和密码。
            try {
                currentUser.login(token); // 调用 Subject$login 方法执行登录
            } catch (AuthenticationException ae) { // 认证异常
                System.out.println("登录失败" + ae.getMessage());
            }
        }
        return "redirect:/list.jsp";
    }
}
```



### 3.6 获取用户名和密码。




### 3.7 把用户名和密码封装为 UsernamePasswordToken 类型对象

```java
// 把用户名和密码封装成一个 token 对象（UsernamePasswordToken类型）
UsernamePasswordToken token = new UsernamePasswordToken("lonestarr", "vespa");
```

### 3.8 设置是否需要记住我（保存登录）

```java
token.setRememberMe(true); // 设置是否记住我。也就是记住用户名和密码。
```

### 3.9 执行登录

```java
try {
    currentUser.login(token); // 调用 Subject$login 方法执行登录
} catch (UnknownAccountException uae) { // 未知账户异常
    log.error("There is no user with username of " + token.getPrincipal());
} catch (IncorrectCredentialsException ice) { // 错误凭证异常
    log.error("Password for account " + token.getPrincipal() + " was incorrect!");
} catch (LockedAccountException lae) { // 账户锁定异常
    log.error("The account for username " + token.getPrincipal() + " is locked.  " +
                      "Please contact your administrator to unlock it.");
}
// ... catch more exceptions here (maybe custom ones specific to your application?
catch (AuthenticationException ae) { // 认证异常
    //unexpected condition?  error?
}
```


## 第 4 步 自定义 Realm 的方法，从数据库获取对应的记录，返回给 Shiro

### 4.1 实际上仅需要继承 org.apache.shiro.realm.AuthenticatingRealm 类
对字符串进行 MD5 加密

注意：可以在前端就将密码进行一次 MD5 加密（统一盐值）。然后传回后端再进行一次 MD5 加密（随机盐值）。

替换当前 Realm 的 credentialsMatcher 属性。直接使用 HashedCredentialsMatcher 对象。并设置属性加密算法即可。

> 进行 MD5 加密的步骤：
> 1. 在自定义类 MyShrioRealm 的重写 doGetAuthenticationInfo() 方法中。
>     使用复杂构造器
>   - principal：加密实体信息
>   - credentials：密码
>   - credentialsSalt：加密盐值
> 	  - 通过 ByteSource.Util.bytes(username); 来计算盐值。
> 	  - 使用 下面的代码来计算盐值加密后的密码的值。
>         `new SimpleHash(hashAlgorithmName, credentials, salt, hashInterations);`
>   - realmName：Realm 对象名字。
> 
> `return new SimpleAuthenticationInfo(principal, credentials, credentialsSalt, realmName);`
> 
>

### 4.2 实现 doGetAuthenticationInfo(AuthenticationToken) 方法

## 第 5 步 由 Shiro 完成对密码的比对
通过 AuthenticatingRealm 类的 CredentialsMatcher 属性来进行密码的比对。

```java
protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException {
    CredentialsMatcher cm = this.getCredentialsMatcher();
    if (cm != null) {
        if (!cm.doCredentialsMatch(token, info)) {
            String msg = "Submitted credentials for token [" + token + "] did not match the expected credentials.";
            throw new IncorrectCredentialsException(msg);
        }
    } else {
        throw new AuthenticationException("A CredentialsMatcher must be configured in order to verify credentials during authentication.  If you do not wish for credentials to be examined, you can configure an " + AllowAllCredentialsMatcher.class.getName() + " instance.");
    }
}
```







# 二、Shiro 认证源码执行流程

## 第 1 步 前端请求命中 Controller

```java
package com.lft.shiro.controller;

import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.subject.Subject;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@RequestMapping ("shiro")
public class ShiroController {
    
    @PostMapping ("login")
    public String login(@RequestParam ("username") String username, @RequestParam ("password") String password) {
        Subject currentUser = SecurityUtils.getSubject();
        
        // 测试当前的用户是否已经被认证，是否已经登录。
        // 调用 Subject$isAuthenticated() 方法
        if (!currentUser.isAuthenticated()) {
            // 把用户名和密码封装成一个 token 对象（UsernamePasswordToken类型）
            UsernamePasswordToken token = new UsernamePasswordToken(username, password);
            // token.setRememberMe(true); // 设置是否记住我。也就是记住用户名和密码。
            try {
                currentUser.login(token); // 调用 Subject$login 方法执行登录
            } catch (AuthenticationException ae) { // 认证异常
                System.out.println("登录失败" + ae.getMessage());
            }
        }
        return "redirect:/list.jsp";
    }
}
```



## 第 2 步 Controller 调用 Subject 的 login 方法

```java
public void login(AuthenticationToken token) throws AuthenticationException {
    this.clearRunAsIdentitiesInternal();
    Subject subject = this.securityManager.login(this, token); // 调用安全管理器的 login 
    String host = null;
    PrincipalCollection principals;
    if (subject instanceof DelegatingSubject) {
        DelegatingSubject delegating = (DelegatingSubject)subject;
        principals = delegating.principals;
        host = delegating.host;
    } else {
        principals = subject.getPrincipals();
    }

    if (principals != null && !principals.isEmpty()) {
        this.principals = principals;
        this.authenticated = true;
        if (token instanceof HostAuthenticationToken) {
            host = ((HostAuthenticationToken)token).getHost();
        }

        if (host != null) {
            this.host = host;
        }

        Session session = subject.getSession(false);
        if (session != null) {
            this.session = this.decorate(session);
        } else {
            this.session = null;
        }

    } else {
        String msg = "Principals returned from securityManager.login( token ) returned a null or empty value.  This value must be non null and populated with one or more elements.";
        throw new IllegalStateException(msg);
    }
}
```



## 第 3 步 调用 DefaultSecurityManager 的 login 方法

```java
public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException {
    AuthenticationInfo info;
    try {
        info = authenticate(token); // 调用鉴别方法 authenticate() 获取认证信息
    } catch (AuthenticationException ae) {
        try {
            onFailedLogin(token, ae, subject);
        } catch (Exception e) {
            if (log.isInfoEnabled()) {
                log.info("onFailedLogin method threw an " +
                        "exception.  Logging and propagating original AuthenticationException.", e);
            }
        }
        throw ae; //propagate
    }

    Subject loggedIn = createSubject(token, info, subject);

    onSuccessfulLogin(token, info, loggedIn);

    return loggedIn;
}
```

## 第 4 步 调用 DefaultSecurityManager 的 authenticate 方法

```java
public AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException {
    return this.authenticator.authenticate(token); // 调用鉴别器的认证方法
}
```



## 第 5 步 父类 AbstractAuthenticator 的 authenticate 方法中调用 doAuthenticate 方法

```java
protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {
    assertRealmsConfigured();
    Collection<Realm> realms = getRealms(); // 获取所有的Realms
    if (realms.size() == 1) {
        return doSingleRealmAuthentication(realms.iterator().next(), authenticationToken); // 如果只有一个 realm 执行 单 Realm 认证方法
    } else {
        return doMultiRealmAuthentication(realms, authenticationToken); // 如果有多个 Realm 执行多 Realm 认证方法
    }
}
```

### 5.1 首先调用 getRealms() 方法获取 Realms

```java
protected Collection<Realm> getRealms() {
    return this.realms;
}
```

### 5.2 判断 realms 中 Realm 的数量是单个还是多个

```java
if (realms.size() == 1) {
    return doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);
} else {
    return doMultiRealmAuthentication(realms, authenticationToken);
}
```

### 5.3 如果只有一个，执行 doSingleRealmAuthentication() 方法

```java
protected AuthenticationInfo doSingleRealmAuthentication(Realm realm, AuthenticationToken token) {
    if (!realm.supports(token)) {
        String msg = "Realm [" + realm + "] does not support authentication token [" +
                token + "].  Please ensure that the appropriate Realm implementation is " +
                "configured correctly or that the realm accepts AuthenticationTokens of this type.";
        throw new UnsupportedTokenException(msg);
    }
    AuthenticationInfo info = realm.getAuthenticationInfo(token); // 执行 realm 的获取认证信息方法 getAuthenticationInfo
    if (info == null) {
        String msg = "Realm [" + realm + "] was unable to find account data for the " +
                "submitted AuthenticationToken [" + token + "].";
        throw new UnknownAccountException(msg);
    }
    return info; // 返回认证信息
}
```

#### 5.3.1 调用 Realm 实现类 AuthenticatingRealm 的 getAuthenticationInfo() 方法获取 AuthenticationInfo 对象

```java
public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {

    AuthenticationInfo info = getCachedAuthenticationInfo(token); // 先从缓存中获取认证信息。
    if (info == null) {
        //otherwise not cached, perform the lookup: // 如果缓存中没有
        info = doGetAuthenticationInfo(token); // 执行 获取认证信息的方法
        log.debug("Looked up AuthenticationInfo [{}] from doGetAuthenticationInfo", info);
        if (token != null && info != null) {
            cacheAuthenticationInfoIfPossible(token, info); // 如果可能缓存认证信息
        }
    } else {
        log.debug("Using cached authentication info [{}] to perform credentials matching.", info);
    }

    if (info != null) {
        assertCredentialsMatch(token, info); // 校验 token 和 info 的密码是否匹配
    } else {
        log.debug("No AuthenticationInfo found for submitted AuthenticationToken [{}].  Returning null.", token);
    }

    return info;
}
```

##### 5.3.1.1 调用自定义 Realm 实现类的 doGetAuthenticationInfo() 方法获取 AuthenticationInfo 对象

```java
package com.lft.shiro.realms;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.LockedAccountException;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.crypto.hash.SimpleHash;
import org.apache.shiro.realm.AuthenticatingRealm;
import org.apache.shiro.util.ByteSource;

public class MyShiroRealm extends AuthenticatingRealm {
    
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        System.out.println("[FirstRealm] 执行了 doGetAuthenticationInfo 方法，传入的 token 为：" + token);
        // 1. 把传入的 AuthenticationToken 类型的 token 对象转换为 UsernamePasswordToken 类型
        UsernamePasswordToken tokenUsernamePassword = (UsernamePasswordToken) token;
        // 2. 从 UsernamePasswordToken 对象中获取 username 和 password
        String username = tokenUsernamePassword.getUsername();
        String password = new String(tokenUsernamePassword.getPassword());
        
        // 3. 调用数据库的方法，从数据库中查询 username 对应的用户记录
        System.out.println("从数据库中获取用户记录：" + username + " 所对应的用户信息。");
        
        // 4. 若用户不存在，则可以抛出 UnknowAccountException 异常。
        if ("unknown".equals(username)) {
            throw new UnknownAccountException("用户不存在");
        }
        
        // 5. 根据用户信息的情况，决定是否抛出其他 AuthenticationException 异常
        if ("monster".equals(username)) {
            throw new LockedAccountException("账户被锁定异常");
        }
        
        // 6. 根据用户信息，构建 AuthenticationInfo 对象并返回，通常的实现类是 SimpleAuthenticationInfo
        // 以下信息是从数据库中获取的。
        // ① principal：认证的实体信息。可以是 username，也可以是数据表对应的用户的实体类对象。
        Object principal = username;
        // ② credentials：数据库中获取的密码
        Object credentials = null;
        if ("admin".equals(username)) {
            credentials = "928bfd2577490322a6e19b793691467e";
        } else if ("user".equals(username)) {
            credentials = "b8c2d5b0a37cc51f91d5e8970347a3a3";
        }
        // ③ credentialsSalt：加密盐值
        ByteSource credentialsSalt = ByteSource.Util.bytes(username);
        // ④ realmName：当前 Realm 对象的 name。调用 父类的 getName() 方法即可获取。
        String realmName = getName();
        
        // SimpleAuthenticationInfo 用于封装从数据库或者缓存中查询到的用户信息。
        return new SimpleAuthenticationInfo(principal, credentials, credentialsSalt, realmName);
    }
}
```

###### 5.3.1.1.1 创建 new SimpleAuthenticationInfo(principal, credentials, credentialsSalt, realmName); 新子类对象返回

```java
public SimpleAuthenticationInfo(Object principal, Object hashedCredentials, ByteSource credentialsSalt, String realmName) {
    this.principals = new SimplePrincipalCollection(principal, realmName); // 初始化主体
    this.credentials = hashedCredentials; // 密码
    this.credentialsSalt = credentialsSalt; // 加盐
}
```

##### 5.3.1.2 调用 assertCredentialsMatch() 方法校验 token 和 info 对象是否匹配。

```java
protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException {
    CredentialsMatcher cm = getCredentialsMatcher(); // 获取凭证匹配器
    if (cm != null) {
        if (!cm.doCredentialsMatch(token, info)) { // 调用凭证匹配器的方法来判断 token 和 info 是否匹配
            //not successful - throw an exception to indicate this:
            String msg = "Submitted credentials for token [" + token + "] did not match the expected credentials.";
            throw new IncorrectCredentialsException(msg);
        }
    } else {
        throw new AuthenticationException("A CredentialsMatcher must be configured in order to verify " +
                "credentials during authentication.  If you do not wish for credentials to be examined, you " +
                "can configure an " + AllowAllCredentialsMatcher.class.getName() + " instance.");
    }
}
```

##### 5.3.1.3 调用 HashedCredentialsMatcher 的 doCredentialsMatch 方法来校验

```java
public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
    Object tokenHashedCredentials = hashProvidedCredentials(token, info); // 通过 info 获取盐来计算出 token 的密码。
    Object accountCredentials = getCredentials(info); // 获取 info 中的密码
    return equals(tokenHashedCredentials, accountCredentials); // 比较两密码。
}
```



### 5.4 如果有多个，执行 doMultiRealmAuthentication() 方法

```java
protected AuthenticationInfo doMultiRealmAuthentication(Collection<Realm> realms, AuthenticationToken token) {
    AuthenticationStrategy strategy = getAuthenticationStrategy(); // 获取认证策略

    AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token); // 创建一个 SimpleAuthenticationInfo 对象

    if (log.isTraceEnabled()) {
        log.trace("Iterating through {} realms for PAM authentication", realms.size());
    }

    for (Realm realm : realms) {

        aggregate = strategy.beforeAttempt(realm, token, aggregate); // 尝试认证之前，校验 aggregate 不为空。并且 里面的校验主体不是空。

        if (realm.supports(token)) { // token 是不是 AuthenticationToken 的实现类或子接口

            log.trace("Attempting to authenticate token [{}] using realm [{}]", token, realm);

            AuthenticationInfo info = null;
            Throwable t = null;
            try {
                info = realm.getAuthenticationInfo(token); // 尝试进行认证得到认证信息
            } catch (Throwable throwable) {
                t = throwable;
                if (log.isDebugEnabled()) {
                    String msg = "Realm [" + realm + "] threw an exception during a multi-realm authentication attempt:";
                    log.debug(msg, t);
                }
            }

            aggregate = strategy.afterAttempt(realm, token, info, aggregate, t); // 合并两个认证信息

        } else {
            log.debug("Realm [{}] does not support token {}.  Skipping realm.", realm, token);
        }
    }

    aggregate = strategy.afterAllAttempts(token, aggregate); // 校验认证信息不为空，密码也不空。

    return aggregate;
}
```





# 三、Shiro 授权流程思路分析

## 1. 授权需要继承自 AuthorizingRealm 类，并实现其 doGetAuthorizationInfo() 方法



## 2. AuthorizingRealm 类 继承自 AuthenticatingRealm 类 但没有实现 doGetAuthenticationInfo() 方法



## 3. 认证和授权只需要继承 AuthorizingRealm 类。同时实现两个抽象方法即可。

